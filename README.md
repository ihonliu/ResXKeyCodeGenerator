# ResXKeyCodeGenerator
ResX Designer Key Source Generator. Generates a const list for source.

This repo is a simplified version from the original [VocaDB/ResXFileCodeGenerator](https://github.com/VocaDB/ResXFileCodeGenerator) and [Catglobe/ResXFileCodeGenerator](https://github.com/Catglobe/ResXFileCodeGenerator) for just generating the key of items in resx files.

## Usage

Install the `Ihon.ResXKeyCodeGenerator` package:

```psl
dotnet add package Ihon.ResXKeyCodeGenerator
```

Generated source from [ActivityEntrySortRuleNames.resx]

```cs
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
#nullable enable
namespace Resources
{
    using System.Globalization;
    using System.Resources;

    public static class ActivityEntrySortRuleNames
    {

        /// <summary>
        /// Name of resource CreateDate.
        /// </summary>
        public const string CreateDate = nameof(CreateDate);

        /// <summary>
        /// Name of resource CreateDateDescending.
        /// </summary>
        public const string CreateDateDescending = nameof(CreateDateDescending);
	}
}
```

## Options

### PublicClass (per file or globally)

Ihon.ResXKeyCodeGenerator generates internal classes by default. You can change this behavior by setting `PublicClass` to `true`.

```xml
<ItemGroup>
  <EmbeddedResource Update="Resources\ArtistCategoriesNames.resx">
    <PublicClass>true</PublicClass>
  </EmbeddedResource>
</ItemGroup>
```
or
```xml
<ItemGroup>
  <EmbeddedResource Update="Resources\ArtistCategoriesNames.resx" PublicClass="true" />
</ItemGroup>
```

If you want to apply this globally, use
```xml
<PropertyGroup>
  <ResXKeyCodeGenerator_PublicClass>true</ResXKeyCodeGenerator_PublicClass>
</PropertyGroup>
```

### Non-static classes (per file or globally)

To use generated resources with [Microsoft.Extensions.Localization](https://docs.microsoft.com/en-us/dotnet/core/extensions/localization) `IStringLocalizer<T>` and resource manager, the resolved type cannot be a static class. You can disable default behaviour per file by setting the value to `false`.

```xml
<ItemGroup>
  <EmbeddedResource Update="Resources\ArtistCategoriesNames.resx">
    <StaticClass>false</StaticClass>
  </EmbeddedResource>
</ItemGroup>
```

or globally

```xml
<PropertyGroup>
  <ResXKeyCodeGenerator_StaticClass>false</ResXKeyCodeGenerator_StaticClass>
</PropertyGroup>
```

With global non-static class you can also reset `StaticClass` per file by setting the value to anything but `false`.

### Partial classes (per file or globally)

To extend an existing class, you can make your classes partial.

```xml
<ItemGroup>
  <EmbeddedResource Update="Resources\ArtistCategoriesNames.resx">
    <PartialClass>true</PartialClass>
  </EmbeddedResource>
</ItemGroup>
```

or globally

```xml
<PropertyGroup>
  <ResXKeyCodeGenerator_PartialClass>true</ResXKeyCodeGenerator_PartialClass>
</PropertyGroup>
```

### Postfix class name (per file or globally)

In some cases the it is useful if the name of the generated class doesn't follow the filename.

A clear example is Razor pages that always generates a class for the code-behind named "-Model".
This example configuration allows you to use Resources.MyResource in your model, or @Model.Resources.MyResource in your cshtml file.

```xml
<ItemGroup>
  <EmbeddedResource Update="**/Pages/*.resx">
    <ClassNamePostfix>Model</ClassNamePostfix>
    <StaticMembers>false</StaticMembers>
    <StaticClass>false</StaticClass>
    <PartialClass>true</PartialClass>
    <PublicClass>true</PublicClass>
    <InnerKeyClassVisibility>public</InnerKeyClassVisibility>
    <PartialClass>false</PartialClass>
    <InnerKeyClassName>_Resources</InnerKeyClassName>
  </EmbeddedResource>
</ItemGroup>
```


or just the postfix globally

```xml
<PropertyGroup>
  <ResXKeyCodeGenerator_ClassNamePostfix>Model</ResXKeyCodeGenerator_ClassNamePostfix>
</PropertyGroup>
```

## Inner key class (per file or globally)

If your resx files are organized along with code files, it can be quite useful to ensure that the resources are not accessible outside the specific class the resx file belong to.

```xml
<ItemGroup>
    <EmbeddedResource Update="**/*.resx">
        <DependentUpon>$([System.String]::Copy('%(FileName).cs'))</DependentUpon>
        <InnerKeyClassName>MyResources</InnerKeyClassName>
        <InnerKeyClassVisibility>private</InnerKeyClassVisibility>
        <StaticMembers>false</StaticMembers>
        <StaticClass>false</StaticClass>
        <PartialClass>true</PartialClass>
    </EmbeddedResource>
    <EmbeddedResource Update="**/*.??.resx;**/*.??-??.resx">
        <DependentUpon>$([System.IO.Path]::GetFileNameWithoutExtension('%(FileName)')).resx</DependentUpon>
    </EmbeddedResource>
</ItemGroup>
```

or globally

```xml
<PropertyGroup>
  <ResXKeyCodeGenerator_InnerKeyClassName>MyResources</ResXKeyCodeGenerator_InnerKeyClassName>
  <ResXKeyCodeGenerator_InnerKeyClassVisibility>private</ResXKeyCodeGenerator_InnerKeyClassVisibility>
  <ResXKeyCodeGenerator_StaticMembers>false</ResXKeyCodeGenerator_StaticMembers>
  <ResXKeyCodeGenerator_StaticClass>false</ResXKeyCodeGenerator_StaticClass>
  <ResXKeyCodeGenerator_PartialClass>true</ResXKeyCodeGenerator_PartialClass>
</PropertyGroup>
```

This example would generate files like this:

```cs
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
#nullable enable
namespace Resources
{
    using System.Globalization;
    using System.Resources;

    public partial class ActivityEntryModel
    {
        public class MyResources
        {
            /// <summary>
            /// Looks up a localized string similar to Oldest.
            /// </summary>
            public string? CreateDate => ResourceManager.GetString(nameof(CreateDate), CultureInfo);

            /// <summary>
            /// Looks up a localized string similar to Newest.
            /// </summary>
            public string? CreateDateDescending => ResourceManager.GetString(nameof(CreateDateDescending), CultureInfo);
        }
    }
}
```

### Inner Key Class Visibility (per file or globally)

By default inner key class are not generated, unless this setting is one of the following:

 * Public
 * Internal
 * Protected
 * SameAsOuter

Case is ignored, so you could use "private".

It is also possible to use "NotGenerated" to override on a file if the global setting is to generate inner classes.

```xml
<ItemGroup>
    <EmbeddedResource Update="**/*.resx">
        <InnerKeyClassVisibility>protected</InnerKeyClassVisibility>
    </EmbeddedResource>
</ItemGroup>
```

or globally

```xml
<PropertyGroup>
  <ResXKeyCodeGenerator_InnerKeyClassVisibility>protected</ResXKeyCodeGenerator_InnerKeyClassVisibility>
</PropertyGroup>
```

### Inner Key Class name (per file or globally)

By default the inner class is named "Resources", which can be overriden with this setting:

```xml
<ItemGroup>
    <EmbeddedResource Update="**/*.resx">
        <InnerKeyClassName>MyResources</InnerKeyClassName>
    </EmbeddedResource>
</ItemGroup>
```

or globally

```xml
<PropertyGroup>
  <ResXKeyCodeGenerator_InnerKeyClassName>MyResources</ResXKeyCodeGenerator_InnerKeyClassName>
</PropertyGroup>
```

## Resource file namespaces

Linked resources namespace follow `Link` if it is set. The `Link` setting is also used by msbuild built-in 'resgen.exe' to determine the embedded filename.

Use-case: Linking `.resx` files from outside source (e.g. generated in a localization sub-module by translators) and expose them as "Resources" namespace.

```xml
<ItemGroup>
  <EmbeddedResource Include="..\..\Another.Project\Translations\*.resx">
    <Link>Resources\%(FileName)%(Extension)</Link>
    <PublicClass>true</PublicClass>
    <StaticClass>false</StaticClass>
  </EmbeddedResource>
  <EmbeddedResource Update="..\..\Another.Project\Translations\*.*.resx">
    <DependentUpon>$([System.IO.Path]::GetFilenameWithoutExtension([System.String]::Copy('%(FileName)'))).resx</DependentUpon>
  </EmbeddedResource>
</ItemGroup>
```

You can also use the `TargetPath` to just overwrite the namespace

```xml
<ItemGroup>
  <EmbeddedResource Include="..\..\Another.Project\Translations\*.resx">
    <TargetPath>Resources\%(FileName)%(Extension)</TargetPath>
    <PublicClass>true</PublicClass>
    <StaticClass>false</StaticClass>
  </EmbeddedResource>
  <EmbeddedResource Update="..\..\Another.Project\Translations\*.*.resx">
    <DependentUpon>$([System.IO.Path]::GetFilenameWithoutExtension([System.String]::Copy('%(FileName)'))).resx</DependentUpon>
  </EmbeddedResource>
</ItemGroup>
```

It is also possible to set the namespace using the `CustomToolNamespace` setting. Unlike the `Link` and `TargetPath`, which will prepend the assemblys namespace and includes the filename, the `CustomToolNamespace` is taken verbatim.

```xml
<ItemGroup>
  <EmbeddedResource Update="**\*.resx">
    <CustomToolNamespace>MyNamespace.AllMyResourcesAreBelongToYouNamespace</CustomToolNamespace>
  </EmbeddedResource>
</ItemGroup>
```

## References
- [Introducing C# Source Generators | .NET Blog](https://devblogs.microsoft.com/dotnet/introducing-c-source-generators/)
- [microsoft/CsWin32: A source generator to add a user-defined set of Win32 P/Invoke methods and supporting types to a C# project.](https://github.com/microsoft/cswin32)
- [kenkendk/mdResXKeyCodeGenerator: Resx Designer Generator](https://github.com/kenkendk/mdResXKeyCodeGenerator)
- [dotnet/ResXResourceManager: Manage localization of all ResX-Based resources in one central place.](https://github.com/dotnet/ResXResourceManager)
- [roslyn/source-generators.cookbook.md at master · dotnet/roslyn](https://github.com/dotnet/roslyn/blob/master/docs/features/source-generators.cookbook.md)
- [roslyn/Using Additional Files.md at master · dotnet/roslyn](https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Using%20Additional%20Files.md)
- [ufcpp - YouTube](https://www.youtube.com/channel/UCY-z_9mau6X-Vr4gk2aWtMQ)
- [Original project: VocaDB/ResXKeyCodeGenerator](https://github.com/VocaDB/ResXKeyCodeGenerator)
- [Original project: Catglobe/ResXKeyCodeGenerator](https://github.com/Catglobe/ResXFileCodeGenerator)
